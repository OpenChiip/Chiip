# Copyright: (c) OpenChiip Organization. https://github.com/OpenChiip/Chiip
# Copyright: (c) <aigc@openchiip.com>
# Generated By Model: Qwen2.5-coder
# Released under the AIGCGPL-1.0 License. For more information, see [https://github.com/OpenChiip/AIGCGPL/blob/main/LICENSE].
# This code was generated using a generative artificial intelligence system and is licensed under the Artificial Intelligence Generated Code General Public License (AIGCGPL). 

"""
日志工具模块，提供统一的日志配置和管理功能
"""
import logging
import sys
from pathlib import Path
from typing import Optional, Union, Dict, Any

def setup_logger(
    name: Optional[str] = None,
    level: Union[int, str] = logging.INFO,
    log_file: Optional[str] = None,
    log_format: Optional[str] = None,
    date_format: Optional[str] = None,
    **kwargs: Any
) -> logging.Logger:
    """
    配置并获取日志记录器
    
    Args:
        name: 日志记录器名称，默认为root logger
        level: 日志级别，可以是logging模块的级别常量或对应的字符串
        log_file: 日志文件路径，如果提供则同时输出到文件
        log_format: 日志格式字符串，默认为'%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        date_format: 日期格式字符串，默认为'%Y-%m-%d %H:%M:%S'
        **kwargs: 其他配置参数
            - file_level: 文件日志级别（可选）
            - console_level: 控制台日志级别（可选）
            - encoding: 日志文件编码（默认utf-8）
            - max_bytes: 单个日志文件最大字节数（用于日志轮转）
            - backup_count: 保留的日志文件数量
    
    Returns:
        logging.Logger: 配置好的日志记录器
    """
    # 获取或创建日志记录器
    logger = logging.getLogger(name)
    
    # 如果已经配置过处理器，则先清除
    if logger.hasHandlers():
        logger.handlers.clear()
    
    # 设置日志记录器级别
    logger.setLevel(level)
    
    # 默认格式
    if log_format is None:
        log_format = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    if date_format is None:
        date_format = '%Y-%m-%d %H:%M:%S'
    
    # 创建格式化器
    formatter = logging.Formatter(log_format, date_format)
    
    # 控制台处理器
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setFormatter(formatter)
    console_handler.setLevel(kwargs.get('console_level', level))
    logger.addHandler(console_handler)
    
    # 文件处理器（如果指定了日志文件）
    if log_file:
        file_path = Path(log_file)
        
        # 确保日志目录存在
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        # 检查是否需要日志轮转
        if 'max_bytes' in kwargs and 'backup_count' in kwargs:
            from logging.handlers import RotatingFileHandler
            file_handler = RotatingFileHandler(
                log_file,
                maxBytes=kwargs['max_bytes'],
                backupCount=kwargs['backup_count'],
                encoding=kwargs.get('encoding', 'utf-8')
            )
        else:
            file_handler = logging.FileHandler(
                log_file,
                encoding=kwargs.get('encoding', 'utf-8')
            )
        
        file_handler.setFormatter(formatter)
        file_handler.setLevel(kwargs.get('file_level', level))
        logger.addHandler(file_handler)
    
    return logger

def get_logger(name: Optional[str] = None) -> logging.Logger:
    """
    获取已配置的日志记录器
    
    Args:
        name: 日志记录器名称
    
    Returns:
        logging.Logger: 日志记录器实例
    """
    return logging.getLogger(name)

class LoggerContext:
    """
    日志上下文管理器，用于临时修改日志级别
    
    Example:
        >>> logger = get_logger('example')
        >>> with LoggerContext(logger, logging.DEBUG):
        ...     logger.debug('这条消息会被记录')
        >>> logger.debug('这条消息不会被记录')
    """
    
    def __init__(self, logger: logging.Logger, level: Union[int, str]):
        """
        初始化日志上下文
        
        Args:
            logger: 日志记录器实例
            level: 临时的日志级别
        """
        self.logger = logger
        self.new_level = level
        self.original_level = logger.getEffectiveLevel()
    
    def __enter__(self) -> logging.Logger:
        """进入上下文"""
        self.logger.setLevel(self.new_level)
        return self.logger
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """退出上下文"""
        self.logger.setLevel(self.original_level)

def log_exception(
    logger: logging.Logger,
    exc_info: Optional[Exception] = None,
    level: int = logging.ERROR,
    message: Optional[str] = None
) -> None:
    """
    记录异常信息
    
    Args:
        logger: 日志记录器实例
        exc_info: 异常信息，默认为当前异常
        level: 日志级别，默认为ERROR
        message: 额外的消息
    """
    if message:
        logger.log(level, message, exc_info=exc_info or True)
    else:
        logger.log(level, "发生异常", exc_info=exc_info or True)

# 预定义的日志格式
LOG_FORMATS = {
    'simple': '%(levelname)s - %(message)s',
    'standard': '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    'detailed': '%(asctime)s - %(name)s - %(levelname)s - %(pathname)s:%(lineno)d - %(message)s',
    'json': '''{
        "timestamp": "%(asctime)s",
        "logger": "%(name)s",
        "level": "%(levelname)s",
        "message": "%(message)s",
        "path": "%(pathname)s",
        "line": %(lineno)d
    }'''.replace('\n', '').replace('    ', '')
}

# 预定义的日期格式
DATE_FORMATS = {
    'standard': '%Y-%m-%d %H:%M:%S',
    'iso': '%Y-%m-%dT%H:%M:%S%z',
    'short': '%H:%M:%S'
}

def configure_root_logger(
    level: Union[int, str] = logging.INFO,
    format_preset: str = 'standard',
    date_preset: str = 'standard',
    **kwargs: Any
) -> None:
    """
    配置根日志记录器
    
    Args:
        level: 日志级别
        format_preset: 预定义格式名称
        date_preset: 预定义日期格式名称
        **kwargs: 其他配置参数，与setup_logger相同
    """
    setup_logger(
        level=level,
        log_format=LOG_FORMATS.get(format_preset, LOG_FORMATS['standard']),
        date_format=DATE_FORMATS.get(date_preset, DATE_FORMATS['standard']),
        **kwargs
    )