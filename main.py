#!/usr/bin/env python3
# Copyright: (c) OpenChiip Organization. https://github.com/OpenChiip/Chiip
# Copyright: (c) <aigc@openchiip.com>
# Generated By Model: Qwen2.5-coder
# Released under the AIGCGPL-1.0 License. For more information, see [https://github.com/OpenChiip/AIGCGPL/blob/main/LICENSE].
# This code was generated using a generative artificial intelligence system and is licensed under the Artificial Intelligence Generated Code General Public License (AIGCGPL). 

"""
Chiip - AI编程助手
主程序入口
"""
import argparse
import asyncio
import json
import logging
import os
import subprocess
import sys
from pathlib import Path

from rich.console import Console

from ai_interface import AIAssistant, AIModelFactory
from cli import CLI
from config import Config, load_config
from file_manager import FileManager
from project import Project
from utils.logger import setup_logger
from utils.text_processing import process_json_string

logger = logging.getLogger(__name__)
console = Console()

class CodeGenerator:
    def __init__(self, config: Config, workspace_dir: str = None):
        """
        初始化代码生成器
        
        Args:
            config: 配置对象
            workspace_dir: 工作目录路径（可选，如果不提供则使用配置中的值）
        """
        self.config = config
        self.workspace_dir = Path(workspace_dir or config.get('workspace_dir'))
        if not self.workspace_dir.exists():
            self.workspace_dir.mkdir(parents=True)
        
        self.file_manager = FileManager(str(self.workspace_dir))
        self.project = Project(str(self.workspace_dir))
        self.ai_assistant = AIAssistant(config)
        
        logger.info(f"工作目录: {self.workspace_dir.absolute()}")

    async def process_requirement(self, requirement: str):
        """
        处理用户需求
        
        Args:
            requirement: 用户输入的需求描述
        """
        logger.info("收到需求: %s", requirement)
        
        try:
            # 调用AI助手处理请求
            result = await self.ai_assistant.process_request(requirement)
            
           # 显示响应
            self._process_result(result)

            # 解析 JSON 响应
            processed_json = process_json_string(result['response'])
            result_json = json.loads(processed_json)

            # 创建工作目录（使用项目ID作为目录名）
            workspace_dir = os.path.join('workspace', result_json['id'])
            if not os.path.exists(workspace_dir):
                os.makedirs(workspace_dir)
            
            # 切换到工作目录
            original_dir = os.getcwd()
            os.chdir(workspace_dir)
            
            print(f"\nInitializing project: {result_json['title']} ({result_json['id']})")
            print(f"Working directory: {workspace_dir}")
            
            try:
                # 遍历所有项目
                for project in result_json['artifact']:
                    print(f"\nProcessing {project['type']} project: {project['name']} ({project['id']})")
                    
                    # 根据项目ID创建子目录
                    project_dir = project['id']
                    if not os.path.exists(project_dir):
                        os.makedirs(project_dir)
                    
                    # 切换到项目目录
                    project_original_dir = os.getcwd()
                    os.chdir(project_dir)
                    print(f"Working in project directory: {os.getcwd()}")
                    
                    try:
                        # 遍历项目中的所有操作
                        for action in project['actions']:
                            if action['type'] == 'file':
                                try:
                                    # 创建文件
                                    # 确保目录存在
                                    file_path = action['filePath']
                                    directory = os.path.dirname(file_path)
                                    if directory and not os.path.exists(directory):
                                        os.makedirs(directory)
                                    
                                    # 使用 file_manager 创建文件
                                    self.file_manager.create_file(file_path, action['content'])
                                    print(f"Created file: {file_path}")
                                except Exception as e:
                                    print(f"Error creating file {file_path}: {e}")
                                    raise
                            
                            elif action['type'] == 'shell':
                                # 执行 shell 命令
                                command = action['command']
                                print(f"Executing command: {command}")
                                result = subprocess.run(command, shell=True, capture_output=True, text=True)
                                
                                # 打印命令输出（如果有）
                                if result.stdout:
                                    print(f"Command output:\n{result.stdout}")
                                
                                # 如果命令执行失败，打印错误信息但继续执行
                                if result.returncode != 0:
                                    print(f"Command failed with return code: {result.returncode}")
                                    if result.stderr:
                                        print(f"Command error:\n{result.stderr}")
                                
                                print(f"Command execution completed with status code: {result.returncode}")
                    finally:
                        # 返回到上一级目录
                        os.chdir(project_original_dir)
                
                print(f"\nProject {result_json['title']} setup completed successfully!")
                
            finally:
                # 恢复原始工作目录
                os.chdir(original_dir)     
            
        except Exception as e:
            logger.error(f"处理请求时出错: {e}", exc_info=True)
            console.print(f"[red]处理请求时出错: {e}[/red]")
    
    def _process_result(self, result: dict):
        """
        处理AI助手返回的结果
        
        Args:
            result: AI助手返回的结果字典
        """
        # 记录原始响应
        logger.info("\n[bold]AI助手响应:[/bold]")
        logger.info(result['response'])
        
        
def parse_arguments():
    """解析命令行参数"""
    parser = argparse.ArgumentParser(description='Chiip - AI编程助手')
    parser.add_argument(
        '--requirement',
        type=str,
        help='需求描述'
    )
    parser.add_argument(
        '--requirement-file',
        type=str,
        help='需求描述文件路径'
    )
    parser.add_argument(
        '--workspace', 
        default='workspace',
        help='代码生成的工作目录 (默认: workspace)'
    )
    parser.add_argument(
        '--config',
        type=str,
        help='配置文件路径'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='启用调试模式'
    )
    parser.add_argument(
        '--interactive',
        action='store_true',
        help='启动交互式命令行界面'
    )
    
    return parser.parse_args()

async def process_requirement(requirement, config):
    """
    处理单个需求
    
    Args:
        requirement: 需求文本
        config: 配置对象
    """
    generator = CodeGenerator(config)
    await generator.process_requirement(requirement)

async def main():
    """主函数"""
    # 解析命令行参数
    args = parse_arguments()
    
    # 设置日志级别
    log_level = 'DEBUG' if args.debug else 'INFO'
    setup_logger(level=log_level)
    
    # 加载配置
    config = load_config(args.config)
    config.set('workspace_dir', args.workspace)
    config.set('log_level', log_level)
    
    try:
        if args.interactive:
            # 启动交互式命令行界面
            cli = CLI()
            await cli.run()
        elif args.requirement:
            # 处理命令行需求
            await process_requirement(args.requirement, config)
        elif args.requirement_file:
            # 处理需求文件
            try:
                with open(args.requirement_file, 'r', encoding='utf-8') as f:
                    requirement = f.read()
                await process_requirement(requirement, config)
            except Exception as e:
                logger.error(f"读取需求文件时出错: {e}", exc_info=args.debug)
                sys.exit(1)
        else:
            # 默认启动交互式界面
            cli = CLI()
            await cli.run()
    
    except KeyboardInterrupt:
        logger.info("程序被用户中断")
    except Exception as e:
        logger.error(f"程序运行时出错: {e}", exc_info=args.debug)
        sys.exit(1)
    
    logger.info("Chiip AI编程助手已退出")

if __name__ == '__main__':
    asyncio.run(main())